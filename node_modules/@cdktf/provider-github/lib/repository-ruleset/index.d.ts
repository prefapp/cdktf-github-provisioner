/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface RepositoryRulesetConfig extends cdktf.TerraformMetaArguments {
    /**
    * Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#enforcement RepositoryRuleset#enforcement}
    */
    readonly enforcement: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#id RepositoryRuleset#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /**
    * The name of the ruleset.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#name RepositoryRuleset#name}
    */
    readonly name: string;
    /**
    * Name of the repository to apply rulset to.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#repository RepositoryRuleset#repository}
    */
    readonly repository?: string;
    /**
    * Possible values are `branch` and `tag`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#target RepositoryRuleset#target}
    */
    readonly target: string;
    /**
    * bypass_actors block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#bypass_actors RepositoryRuleset#bypass_actors}
    */
    readonly bypassActors?: RepositoryRulesetBypassActors[] | cdktf.IResolvable;
    /**
    * conditions block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#conditions RepositoryRuleset#conditions}
    */
    readonly conditions?: RepositoryRulesetConditions;
    /**
    * rules block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#rules RepositoryRuleset#rules}
    */
    readonly rules: RepositoryRulesetRules;
}
export interface RepositoryRulesetBypassActors {
    /**
    * The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#actor_id RepositoryRuleset#actor_id}
    */
    readonly actorId: number;
    /**
    * The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#actor_type RepositoryRuleset#actor_type}
    */
    readonly actorType: string;
    /**
    * When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#bypass_mode RepositoryRuleset#bypass_mode}
    */
    readonly bypassMode: string;
}
export declare function repositoryRulesetBypassActorsToTerraform(struct?: RepositoryRulesetBypassActors | cdktf.IResolvable): any;
export declare class RepositoryRulesetBypassActorsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    private resolvableValue?;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    * @param complexObjectIndex the index of this item in the list
    * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean);
    get internalValue(): RepositoryRulesetBypassActors | cdktf.IResolvable | undefined;
    set internalValue(value: RepositoryRulesetBypassActors | cdktf.IResolvable | undefined);
    private _actorId?;
    get actorId(): number;
    set actorId(value: number);
    get actorIdInput(): number | undefined;
    private _actorType?;
    get actorType(): string;
    set actorType(value: string);
    get actorTypeInput(): string | undefined;
    private _bypassMode?;
    get bypassMode(): string;
    set bypassMode(value: string);
    get bypassModeInput(): string | undefined;
}
export declare class RepositoryRulesetBypassActorsList extends cdktf.ComplexList {
    protected terraformResource: cdktf.IInterpolatingParent;
    protected terraformAttribute: string;
    protected wrapsSet: boolean;
    internalValue?: RepositoryRulesetBypassActors[] | cdktf.IResolvable;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, wrapsSet: boolean);
    /**
    * @param index the index of the item to return
    */
    get(index: number): RepositoryRulesetBypassActorsOutputReference;
}
export interface RepositoryRulesetConditionsRefName {
    /**
    * Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#exclude RepositoryRuleset#exclude}
    */
    readonly exclude: string[];
    /**
    * Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#include RepositoryRuleset#include}
    */
    readonly include: string[];
}
export declare function repositoryRulesetConditionsRefNameToTerraform(struct?: RepositoryRulesetConditionsRefNameOutputReference | RepositoryRulesetConditionsRefName): any;
export declare class RepositoryRulesetConditionsRefNameOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetConditionsRefName | undefined;
    set internalValue(value: RepositoryRulesetConditionsRefName | undefined);
    private _exclude?;
    get exclude(): string[];
    set exclude(value: string[]);
    get excludeInput(): string[] | undefined;
    private _include?;
    get include(): string[];
    set include(value: string[]);
    get includeInput(): string[] | undefined;
}
export interface RepositoryRulesetConditions {
    /**
    * ref_name block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#ref_name RepositoryRuleset#ref_name}
    */
    readonly refName: RepositoryRulesetConditionsRefName;
}
export declare function repositoryRulesetConditionsToTerraform(struct?: RepositoryRulesetConditionsOutputReference | RepositoryRulesetConditions): any;
export declare class RepositoryRulesetConditionsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetConditions | undefined;
    set internalValue(value: RepositoryRulesetConditions | undefined);
    private _refName;
    get refName(): RepositoryRulesetConditionsRefNameOutputReference;
    putRefName(value: RepositoryRulesetConditionsRefName): void;
    get refNameInput(): RepositoryRulesetConditionsRefName | undefined;
}
export interface RepositoryRulesetRulesBranchNamePattern {
    /**
    * How this rule will appear to users.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#name RepositoryRuleset#name}
    */
    readonly name?: string;
    /**
    * If true, the rule will fail if the pattern matches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#negate RepositoryRuleset#negate}
    */
    readonly negate?: boolean | cdktf.IResolvable;
    /**
    * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#operator RepositoryRuleset#operator}
    */
    readonly operator: string;
    /**
    * The pattern to match with.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#pattern RepositoryRuleset#pattern}
    */
    readonly pattern: string;
}
export declare function repositoryRulesetRulesBranchNamePatternToTerraform(struct?: RepositoryRulesetRulesBranchNamePatternOutputReference | RepositoryRulesetRulesBranchNamePattern): any;
export declare class RepositoryRulesetRulesBranchNamePatternOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesBranchNamePattern | undefined;
    set internalValue(value: RepositoryRulesetRulesBranchNamePattern | undefined);
    private _name?;
    get name(): string;
    set name(value: string);
    resetName(): void;
    get nameInput(): string | undefined;
    private _negate?;
    get negate(): boolean | cdktf.IResolvable;
    set negate(value: boolean | cdktf.IResolvable);
    resetNegate(): void;
    get negateInput(): boolean | cdktf.IResolvable | undefined;
    private _operator?;
    get operator(): string;
    set operator(value: string);
    get operatorInput(): string | undefined;
    private _pattern?;
    get pattern(): string;
    set pattern(value: string);
    get patternInput(): string | undefined;
}
export interface RepositoryRulesetRulesCommitAuthorEmailPattern {
    /**
    * How this rule will appear to users.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#name RepositoryRuleset#name}
    */
    readonly name?: string;
    /**
    * If true, the rule will fail if the pattern matches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#negate RepositoryRuleset#negate}
    */
    readonly negate?: boolean | cdktf.IResolvable;
    /**
    * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#operator RepositoryRuleset#operator}
    */
    readonly operator: string;
    /**
    * The pattern to match with.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#pattern RepositoryRuleset#pattern}
    */
    readonly pattern: string;
}
export declare function repositoryRulesetRulesCommitAuthorEmailPatternToTerraform(struct?: RepositoryRulesetRulesCommitAuthorEmailPatternOutputReference | RepositoryRulesetRulesCommitAuthorEmailPattern): any;
export declare class RepositoryRulesetRulesCommitAuthorEmailPatternOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesCommitAuthorEmailPattern | undefined;
    set internalValue(value: RepositoryRulesetRulesCommitAuthorEmailPattern | undefined);
    private _name?;
    get name(): string;
    set name(value: string);
    resetName(): void;
    get nameInput(): string | undefined;
    private _negate?;
    get negate(): boolean | cdktf.IResolvable;
    set negate(value: boolean | cdktf.IResolvable);
    resetNegate(): void;
    get negateInput(): boolean | cdktf.IResolvable | undefined;
    private _operator?;
    get operator(): string;
    set operator(value: string);
    get operatorInput(): string | undefined;
    private _pattern?;
    get pattern(): string;
    set pattern(value: string);
    get patternInput(): string | undefined;
}
export interface RepositoryRulesetRulesCommitMessagePattern {
    /**
    * How this rule will appear to users.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#name RepositoryRuleset#name}
    */
    readonly name?: string;
    /**
    * If true, the rule will fail if the pattern matches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#negate RepositoryRuleset#negate}
    */
    readonly negate?: boolean | cdktf.IResolvable;
    /**
    * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#operator RepositoryRuleset#operator}
    */
    readonly operator: string;
    /**
    * The pattern to match with.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#pattern RepositoryRuleset#pattern}
    */
    readonly pattern: string;
}
export declare function repositoryRulesetRulesCommitMessagePatternToTerraform(struct?: RepositoryRulesetRulesCommitMessagePatternOutputReference | RepositoryRulesetRulesCommitMessagePattern): any;
export declare class RepositoryRulesetRulesCommitMessagePatternOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesCommitMessagePattern | undefined;
    set internalValue(value: RepositoryRulesetRulesCommitMessagePattern | undefined);
    private _name?;
    get name(): string;
    set name(value: string);
    resetName(): void;
    get nameInput(): string | undefined;
    private _negate?;
    get negate(): boolean | cdktf.IResolvable;
    set negate(value: boolean | cdktf.IResolvable);
    resetNegate(): void;
    get negateInput(): boolean | cdktf.IResolvable | undefined;
    private _operator?;
    get operator(): string;
    set operator(value: string);
    get operatorInput(): string | undefined;
    private _pattern?;
    get pattern(): string;
    set pattern(value: string);
    get patternInput(): string | undefined;
}
export interface RepositoryRulesetRulesCommitterEmailPattern {
    /**
    * How this rule will appear to users.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#name RepositoryRuleset#name}
    */
    readonly name?: string;
    /**
    * If true, the rule will fail if the pattern matches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#negate RepositoryRuleset#negate}
    */
    readonly negate?: boolean | cdktf.IResolvable;
    /**
    * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#operator RepositoryRuleset#operator}
    */
    readonly operator: string;
    /**
    * The pattern to match with.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#pattern RepositoryRuleset#pattern}
    */
    readonly pattern: string;
}
export declare function repositoryRulesetRulesCommitterEmailPatternToTerraform(struct?: RepositoryRulesetRulesCommitterEmailPatternOutputReference | RepositoryRulesetRulesCommitterEmailPattern): any;
export declare class RepositoryRulesetRulesCommitterEmailPatternOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesCommitterEmailPattern | undefined;
    set internalValue(value: RepositoryRulesetRulesCommitterEmailPattern | undefined);
    private _name?;
    get name(): string;
    set name(value: string);
    resetName(): void;
    get nameInput(): string | undefined;
    private _negate?;
    get negate(): boolean | cdktf.IResolvable;
    set negate(value: boolean | cdktf.IResolvable);
    resetNegate(): void;
    get negateInput(): boolean | cdktf.IResolvable | undefined;
    private _operator?;
    get operator(): string;
    set operator(value: string);
    get operatorInput(): string | undefined;
    private _pattern?;
    get pattern(): string;
    set pattern(value: string);
    get patternInput(): string | undefined;
}
export interface RepositoryRulesetRulesPullRequest {
    /**
    * New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#dismiss_stale_reviews_on_push RepositoryRuleset#dismiss_stale_reviews_on_push}
    */
    readonly dismissStaleReviewsOnPush?: boolean | cdktf.IResolvable;
    /**
    * Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#require_code_owner_review RepositoryRuleset#require_code_owner_review}
    */
    readonly requireCodeOwnerReview?: boolean | cdktf.IResolvable;
    /**
    * Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#require_last_push_approval RepositoryRuleset#require_last_push_approval}
    */
    readonly requireLastPushApproval?: boolean | cdktf.IResolvable;
    /**
    * The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_approving_review_count RepositoryRuleset#required_approving_review_count}
    */
    readonly requiredApprovingReviewCount?: number;
    /**
    * All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_review_thread_resolution RepositoryRuleset#required_review_thread_resolution}
    */
    readonly requiredReviewThreadResolution?: boolean | cdktf.IResolvable;
}
export declare function repositoryRulesetRulesPullRequestToTerraform(struct?: RepositoryRulesetRulesPullRequestOutputReference | RepositoryRulesetRulesPullRequest): any;
export declare class RepositoryRulesetRulesPullRequestOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesPullRequest | undefined;
    set internalValue(value: RepositoryRulesetRulesPullRequest | undefined);
    private _dismissStaleReviewsOnPush?;
    get dismissStaleReviewsOnPush(): boolean | cdktf.IResolvable;
    set dismissStaleReviewsOnPush(value: boolean | cdktf.IResolvable);
    resetDismissStaleReviewsOnPush(): void;
    get dismissStaleReviewsOnPushInput(): boolean | cdktf.IResolvable | undefined;
    private _requireCodeOwnerReview?;
    get requireCodeOwnerReview(): boolean | cdktf.IResolvable;
    set requireCodeOwnerReview(value: boolean | cdktf.IResolvable);
    resetRequireCodeOwnerReview(): void;
    get requireCodeOwnerReviewInput(): boolean | cdktf.IResolvable | undefined;
    private _requireLastPushApproval?;
    get requireLastPushApproval(): boolean | cdktf.IResolvable;
    set requireLastPushApproval(value: boolean | cdktf.IResolvable);
    resetRequireLastPushApproval(): void;
    get requireLastPushApprovalInput(): boolean | cdktf.IResolvable | undefined;
    private _requiredApprovingReviewCount?;
    get requiredApprovingReviewCount(): number;
    set requiredApprovingReviewCount(value: number);
    resetRequiredApprovingReviewCount(): void;
    get requiredApprovingReviewCountInput(): number | undefined;
    private _requiredReviewThreadResolution?;
    get requiredReviewThreadResolution(): boolean | cdktf.IResolvable;
    set requiredReviewThreadResolution(value: boolean | cdktf.IResolvable);
    resetRequiredReviewThreadResolution(): void;
    get requiredReviewThreadResolutionInput(): boolean | cdktf.IResolvable | undefined;
}
export interface RepositoryRulesetRulesRequiredDeployments {
    /**
    * The environments that must be successfully deployed to before branches can be merged.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_deployment_environments RepositoryRuleset#required_deployment_environments}
    */
    readonly requiredDeploymentEnvironments?: string[];
}
export declare function repositoryRulesetRulesRequiredDeploymentsToTerraform(struct?: RepositoryRulesetRulesRequiredDeploymentsOutputReference | RepositoryRulesetRulesRequiredDeployments): any;
export declare class RepositoryRulesetRulesRequiredDeploymentsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesRequiredDeployments | undefined;
    set internalValue(value: RepositoryRulesetRulesRequiredDeployments | undefined);
    private _requiredDeploymentEnvironments?;
    get requiredDeploymentEnvironments(): string[];
    set requiredDeploymentEnvironments(value: string[]);
    resetRequiredDeploymentEnvironments(): void;
    get requiredDeploymentEnvironmentsInput(): string[] | undefined;
}
export interface RepositoryRulesetRulesRequiredStatusChecksRequiredCheck {
    /**
    * The status check context name that must be present on the commit.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#context RepositoryRuleset#context}
    */
    readonly context: string;
    /**
    * The optional integration ID that this status check must originate from.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#integration_id RepositoryRuleset#integration_id}
    */
    readonly integrationId?: number;
}
export declare function repositoryRulesetRulesRequiredStatusChecksRequiredCheckToTerraform(struct?: RepositoryRulesetRulesRequiredStatusChecksRequiredCheck | cdktf.IResolvable): any;
export declare class RepositoryRulesetRulesRequiredStatusChecksRequiredCheckOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    private resolvableValue?;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    * @param complexObjectIndex the index of this item in the list
    * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean);
    get internalValue(): RepositoryRulesetRulesRequiredStatusChecksRequiredCheck | cdktf.IResolvable | undefined;
    set internalValue(value: RepositoryRulesetRulesRequiredStatusChecksRequiredCheck | cdktf.IResolvable | undefined);
    private _context?;
    get context(): string;
    set context(value: string);
    get contextInput(): string | undefined;
    private _integrationId?;
    get integrationId(): number;
    set integrationId(value: number);
    resetIntegrationId(): void;
    get integrationIdInput(): number | undefined;
}
export declare class RepositoryRulesetRulesRequiredStatusChecksRequiredCheckList extends cdktf.ComplexList {
    protected terraformResource: cdktf.IInterpolatingParent;
    protected terraformAttribute: string;
    protected wrapsSet: boolean;
    internalValue?: RepositoryRulesetRulesRequiredStatusChecksRequiredCheck[] | cdktf.IResolvable;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, wrapsSet: boolean);
    /**
    * @param index the index of the item to return
    */
    get(index: number): RepositoryRulesetRulesRequiredStatusChecksRequiredCheckOutputReference;
}
export interface RepositoryRulesetRulesRequiredStatusChecks {
    /**
    * Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#strict_required_status_checks_policy RepositoryRuleset#strict_required_status_checks_policy}
    */
    readonly strictRequiredStatusChecksPolicy?: boolean | cdktf.IResolvable;
    /**
    * required_check block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_check RepositoryRuleset#required_check}
    */
    readonly requiredCheck: RepositoryRulesetRulesRequiredStatusChecksRequiredCheck[] | cdktf.IResolvable;
}
export declare function repositoryRulesetRulesRequiredStatusChecksToTerraform(struct?: RepositoryRulesetRulesRequiredStatusChecksOutputReference | RepositoryRulesetRulesRequiredStatusChecks): any;
export declare class RepositoryRulesetRulesRequiredStatusChecksOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesRequiredStatusChecks | undefined;
    set internalValue(value: RepositoryRulesetRulesRequiredStatusChecks | undefined);
    private _strictRequiredStatusChecksPolicy?;
    get strictRequiredStatusChecksPolicy(): boolean | cdktf.IResolvable;
    set strictRequiredStatusChecksPolicy(value: boolean | cdktf.IResolvable);
    resetStrictRequiredStatusChecksPolicy(): void;
    get strictRequiredStatusChecksPolicyInput(): boolean | cdktf.IResolvable | undefined;
    private _requiredCheck;
    get requiredCheck(): RepositoryRulesetRulesRequiredStatusChecksRequiredCheckList;
    putRequiredCheck(value: RepositoryRulesetRulesRequiredStatusChecksRequiredCheck[] | cdktf.IResolvable): void;
    get requiredCheckInput(): cdktf.IResolvable | RepositoryRulesetRulesRequiredStatusChecksRequiredCheck[] | undefined;
}
export interface RepositoryRulesetRulesTagNamePattern {
    /**
    * How this rule will appear to users.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#name RepositoryRuleset#name}
    */
    readonly name?: string;
    /**
    * If true, the rule will fail if the pattern matches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#negate RepositoryRuleset#negate}
    */
    readonly negate?: boolean | cdktf.IResolvable;
    /**
    * The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#operator RepositoryRuleset#operator}
    */
    readonly operator: string;
    /**
    * The pattern to match with.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#pattern RepositoryRuleset#pattern}
    */
    readonly pattern: string;
}
export declare function repositoryRulesetRulesTagNamePatternToTerraform(struct?: RepositoryRulesetRulesTagNamePatternOutputReference | RepositoryRulesetRulesTagNamePattern): any;
export declare class RepositoryRulesetRulesTagNamePatternOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRulesTagNamePattern | undefined;
    set internalValue(value: RepositoryRulesetRulesTagNamePattern | undefined);
    private _name?;
    get name(): string;
    set name(value: string);
    resetName(): void;
    get nameInput(): string | undefined;
    private _negate?;
    get negate(): boolean | cdktf.IResolvable;
    set negate(value: boolean | cdktf.IResolvable);
    resetNegate(): void;
    get negateInput(): boolean | cdktf.IResolvable | undefined;
    private _operator?;
    get operator(): string;
    set operator(value: string);
    get operatorInput(): string | undefined;
    private _pattern?;
    get pattern(): string;
    set pattern(value: string);
    get patternInput(): string | undefined;
}
export interface RepositoryRulesetRules {
    /**
    * Only allow users with bypass permission to create matching refs.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#creation RepositoryRuleset#creation}
    */
    readonly creation?: boolean | cdktf.IResolvable;
    /**
    * Only allow users with bypass permissions to delete matching refs.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#deletion RepositoryRuleset#deletion}
    */
    readonly deletion?: boolean | cdktf.IResolvable;
    /**
    * Prevent users with push access from force pushing to branches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#non_fast_forward RepositoryRuleset#non_fast_forward}
    */
    readonly nonFastForward?: boolean | cdktf.IResolvable;
    /**
    * Prevent merge commits from being pushed to matching branches.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_linear_history RepositoryRuleset#required_linear_history}
    */
    readonly requiredLinearHistory?: boolean | cdktf.IResolvable;
    /**
    * Commits pushed to matching branches must have verified signatures.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_signatures RepositoryRuleset#required_signatures}
    */
    readonly requiredSignatures?: boolean | cdktf.IResolvable;
    /**
    * Only allow users with bypass permission to update matching refs.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#update RepositoryRuleset#update}
    */
    readonly update?: boolean | cdktf.IResolvable;
    /**
    * Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#update_allows_fetch_and_merge RepositoryRuleset#update_allows_fetch_and_merge}
    */
    readonly updateAllowsFetchAndMerge?: boolean | cdktf.IResolvable;
    /**
    * branch_name_pattern block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#branch_name_pattern RepositoryRuleset#branch_name_pattern}
    */
    readonly branchNamePattern?: RepositoryRulesetRulesBranchNamePattern;
    /**
    * commit_author_email_pattern block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#commit_author_email_pattern RepositoryRuleset#commit_author_email_pattern}
    */
    readonly commitAuthorEmailPattern?: RepositoryRulesetRulesCommitAuthorEmailPattern;
    /**
    * commit_message_pattern block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#commit_message_pattern RepositoryRuleset#commit_message_pattern}
    */
    readonly commitMessagePattern?: RepositoryRulesetRulesCommitMessagePattern;
    /**
    * committer_email_pattern block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#committer_email_pattern RepositoryRuleset#committer_email_pattern}
    */
    readonly committerEmailPattern?: RepositoryRulesetRulesCommitterEmailPattern;
    /**
    * pull_request block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#pull_request RepositoryRuleset#pull_request}
    */
    readonly pullRequest?: RepositoryRulesetRulesPullRequest;
    /**
    * required_deployments block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_deployments RepositoryRuleset#required_deployments}
    */
    readonly requiredDeployments?: RepositoryRulesetRulesRequiredDeployments;
    /**
    * required_status_checks block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#required_status_checks RepositoryRuleset#required_status_checks}
    */
    readonly requiredStatusChecks?: RepositoryRulesetRulesRequiredStatusChecks;
    /**
    * tag_name_pattern block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#tag_name_pattern RepositoryRuleset#tag_name_pattern}
    */
    readonly tagNamePattern?: RepositoryRulesetRulesTagNamePattern;
}
export declare function repositoryRulesetRulesToTerraform(struct?: RepositoryRulesetRulesOutputReference | RepositoryRulesetRules): any;
export declare class RepositoryRulesetRulesOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): RepositoryRulesetRules | undefined;
    set internalValue(value: RepositoryRulesetRules | undefined);
    private _creation?;
    get creation(): boolean | cdktf.IResolvable;
    set creation(value: boolean | cdktf.IResolvable);
    resetCreation(): void;
    get creationInput(): boolean | cdktf.IResolvable | undefined;
    private _deletion?;
    get deletion(): boolean | cdktf.IResolvable;
    set deletion(value: boolean | cdktf.IResolvable);
    resetDeletion(): void;
    get deletionInput(): boolean | cdktf.IResolvable | undefined;
    private _nonFastForward?;
    get nonFastForward(): boolean | cdktf.IResolvable;
    set nonFastForward(value: boolean | cdktf.IResolvable);
    resetNonFastForward(): void;
    get nonFastForwardInput(): boolean | cdktf.IResolvable | undefined;
    private _requiredLinearHistory?;
    get requiredLinearHistory(): boolean | cdktf.IResolvable;
    set requiredLinearHistory(value: boolean | cdktf.IResolvable);
    resetRequiredLinearHistory(): void;
    get requiredLinearHistoryInput(): boolean | cdktf.IResolvable | undefined;
    private _requiredSignatures?;
    get requiredSignatures(): boolean | cdktf.IResolvable;
    set requiredSignatures(value: boolean | cdktf.IResolvable);
    resetRequiredSignatures(): void;
    get requiredSignaturesInput(): boolean | cdktf.IResolvable | undefined;
    private _update?;
    get update(): boolean | cdktf.IResolvable;
    set update(value: boolean | cdktf.IResolvable);
    resetUpdate(): void;
    get updateInput(): boolean | cdktf.IResolvable | undefined;
    private _updateAllowsFetchAndMerge?;
    get updateAllowsFetchAndMerge(): boolean | cdktf.IResolvable;
    set updateAllowsFetchAndMerge(value: boolean | cdktf.IResolvable);
    resetUpdateAllowsFetchAndMerge(): void;
    get updateAllowsFetchAndMergeInput(): boolean | cdktf.IResolvable | undefined;
    private _branchNamePattern;
    get branchNamePattern(): RepositoryRulesetRulesBranchNamePatternOutputReference;
    putBranchNamePattern(value: RepositoryRulesetRulesBranchNamePattern): void;
    resetBranchNamePattern(): void;
    get branchNamePatternInput(): RepositoryRulesetRulesBranchNamePattern | undefined;
    private _commitAuthorEmailPattern;
    get commitAuthorEmailPattern(): RepositoryRulesetRulesCommitAuthorEmailPatternOutputReference;
    putCommitAuthorEmailPattern(value: RepositoryRulesetRulesCommitAuthorEmailPattern): void;
    resetCommitAuthorEmailPattern(): void;
    get commitAuthorEmailPatternInput(): RepositoryRulesetRulesCommitAuthorEmailPattern | undefined;
    private _commitMessagePattern;
    get commitMessagePattern(): RepositoryRulesetRulesCommitMessagePatternOutputReference;
    putCommitMessagePattern(value: RepositoryRulesetRulesCommitMessagePattern): void;
    resetCommitMessagePattern(): void;
    get commitMessagePatternInput(): RepositoryRulesetRulesCommitMessagePattern | undefined;
    private _committerEmailPattern;
    get committerEmailPattern(): RepositoryRulesetRulesCommitterEmailPatternOutputReference;
    putCommitterEmailPattern(value: RepositoryRulesetRulesCommitterEmailPattern): void;
    resetCommitterEmailPattern(): void;
    get committerEmailPatternInput(): RepositoryRulesetRulesCommitterEmailPattern | undefined;
    private _pullRequest;
    get pullRequest(): RepositoryRulesetRulesPullRequestOutputReference;
    putPullRequest(value: RepositoryRulesetRulesPullRequest): void;
    resetPullRequest(): void;
    get pullRequestInput(): RepositoryRulesetRulesPullRequest | undefined;
    private _requiredDeployments;
    get requiredDeployments(): RepositoryRulesetRulesRequiredDeploymentsOutputReference;
    putRequiredDeployments(value: RepositoryRulesetRulesRequiredDeployments): void;
    resetRequiredDeployments(): void;
    get requiredDeploymentsInput(): RepositoryRulesetRulesRequiredDeployments | undefined;
    private _requiredStatusChecks;
    get requiredStatusChecks(): RepositoryRulesetRulesRequiredStatusChecksOutputReference;
    putRequiredStatusChecks(value: RepositoryRulesetRulesRequiredStatusChecks): void;
    resetRequiredStatusChecks(): void;
    get requiredStatusChecksInput(): RepositoryRulesetRulesRequiredStatusChecks | undefined;
    private _tagNamePattern;
    get tagNamePattern(): RepositoryRulesetRulesTagNamePatternOutputReference;
    putTagNamePattern(value: RepositoryRulesetRulesTagNamePattern): void;
    resetTagNamePattern(): void;
    get tagNamePatternInput(): RepositoryRulesetRulesTagNamePattern | undefined;
}
/**
* Represents a {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset github_repository_ruleset}
*/
export declare class RepositoryRuleset extends cdktf.TerraformResource {
    static readonly tfResourceType = "github_repository_ruleset";
    /**
    * Generates CDKTF code for importing a RepositoryRuleset resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the RepositoryRuleset to import
    * @param importFromId The id of the existing RepositoryRuleset that should be imported. Refer to the {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the RepositoryRuleset to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/integrations/github/5.40.0/docs/resources/repository_ruleset github_repository_ruleset} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options RepositoryRulesetConfig
    */
    constructor(scope: Construct, id: string, config: RepositoryRulesetConfig);
    private _enforcement?;
    get enforcement(): string;
    set enforcement(value: string);
    get enforcementInput(): string | undefined;
    get etag(): string;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _name?;
    get name(): string;
    set name(value: string);
    get nameInput(): string | undefined;
    get nodeId(): string;
    private _repository?;
    get repository(): string;
    set repository(value: string);
    resetRepository(): void;
    get repositoryInput(): string | undefined;
    get rulesetId(): number;
    private _target?;
    get target(): string;
    set target(value: string);
    get targetInput(): string | undefined;
    private _bypassActors;
    get bypassActors(): RepositoryRulesetBypassActorsList;
    putBypassActors(value: RepositoryRulesetBypassActors[] | cdktf.IResolvable): void;
    resetBypassActors(): void;
    get bypassActorsInput(): cdktf.IResolvable | RepositoryRulesetBypassActors[] | undefined;
    private _conditions;
    get conditions(): RepositoryRulesetConditionsOutputReference;
    putConditions(value: RepositoryRulesetConditions): void;
    resetConditions(): void;
    get conditionsInput(): RepositoryRulesetConditions | undefined;
    private _rules;
    get rules(): RepositoryRulesetRulesOutputReference;
    putRules(value: RepositoryRulesetRules): void;
    get rulesInput(): RepositoryRulesetRules | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
}
